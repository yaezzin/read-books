# 데이터 압축

## 1. 페이지 압축

* 페이지 압축은 MySQL 서버가 디스크에 저장하는 시점에서 데이터 페이지가 압축되어 저장되고, 반대로 버퍼풀에서 데이터 페이지를 읽어올 때는 압축이 해제된다.
* 즉, 메모리에서는 항상 압축된 형태를 유지하지 않으며, 페이지가 flush(즉, 디스크에 다시 쓰여질) 때만 다시 압축되어 저장된다.

### 펀치홀

<img width="433" height="227" alt="스크린샷 2025-10-19 오후 5 38 49" src="https://github.com/user-attachments/assets/ec416cd8-a8a1-4407-bc8e-d05f5e360a4d" />

InnoDB는 모든 데이터를 페이지 단위로 관리하는데, 기본 페이지 크기는 16KB(기본값)이다.
* 페이지 압축은 디스크에 기록할 때 페이지를 압축해서 저장하는 것인데, 데이터를 압축한 결과의 용량이 얼마나 될지 예측이 불가능하다. (압축 결과가 가변적)
* 하지만 테이블의 모든 페이지는 같은 크기(16KB)로 존재해야 하는데, 압축된 결과를 그냥 8KB만 써버리면 나머지는 비어 버리게 된다. (페이지 주소 체계가 깨짐)

따라서 비어버린 나머지 KB를 처리하기 위해 파일시스템의 ```펀치홀``` 기능을 사용한다.
* 리눅스의 `fallocate()` 시스템 콜 중에 `FALLOC_FL_PUNCH_HOLE`이라는 옵션이 존재한다.
* 파일 중간의 특정 범위를 비워서 실제 디스크 블록을 해제하는 기능을 의미한다.
* ```처리 방법```
  * 압축된 페이지(ex. 8KB)를 파일의 해당 위치(16KB 슬롯)에 씀
  * 나머지 8KB 범위는 펀치홀 처리
  * 결과적으로 파일의 논리 크기는 여전히 16KB이지만 물리적으로는 8KB만 디스크 공간을 차지
  * 즉, **16KB 페이지 단위의 주소 체계를 유지하면서 압축된 실제 데이터 크기만큼만 디스크 블록을 사용하도록 해주는 기술**
* 펀치 홀 기능은 운영체제 뿐만 아니라 하드웨어 자체에서도 해당 기능을 지원해야 사용 가능하다.

## 2. 테이블 압축

### 2-1. 압축 테이블 생성

```sql
# 해당 시스템 변수가 on으로 설정된 상태에서 테이블 생성해야 함 
SET GLOBAL innodb_file_per_table=ON;

# 테이블 압축을 사용하는 테이블은 ROW_FORMAT=COMRESSED 옵션을 명시해야함
CREATE TABLE compressed_table (cl INT PRIMARY KEY) ROW_FORMAT=COMRESSED KEY_BLOCK_SIZE=8;

# 압축된 페이지의 타깃 크기(목표 크기) 설정, 2n(n값은 2 이상)으로만 설정 가능
CREATE TABLE compressed_table(c1 INT PRIMARY KEY) KEY_BLOCK_SIZE=8;

# 만약 ROW_FORMAT 옵션을 지정하지 않더라도 자동으로 옵션이 추가되어 생성됨
CREATE TABLE compressed_table (cl INT PRIMARY KEY) KEY_BLOCK_SIZE=8;
```

<img width="279" height="284" alt="스크린샷 2025-10-19 오후 10 57 06" src="https://github.com/user-attachments/assets/af59b304-aa9b-44d8-8edb-e6eecbeb17a8" />

1. 16KB의 데이터 페이지를 압축
  * 압축된 결과가 8KB 이하이면 그대로 디스크에 저장 (압축 완료)
  * 압축된 결과가 8KB를 초과하면 원본 페이지를 스플릿해서 2개의 페이지에 8KB씩 저장
2. 나뉜 페이지 각각에 대해 1번 단계를 반복 실행 

### 2-2. KEY_BLOCK_SIZE 결정

```sql
USE employees;

-- employees 테이블과 동일한 구조로, 테이블 압축을 사용하는 예제 테이블을 생성
CREATE TABLE employees_comp4k (
  emp_no INT NOT NULL,
  birth_date DATE NOT NULL,
  first_name VARCHAR(14) NOT NULL,
  last_name VARCHAR(16) NOT NULL,
  gender ENUM('M', 'F') NOT NULL,
  hire_date DATE NOT NULL,
  PRIMARY KEY (emp_no),
  KEY ix_firstname (first_name),
  KEY ix_hiredate (hire_date)
) ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=4;

-- 테스트를 실행하기 전에 innodb_cmp_per_index_enabled 시스템 변수를 ON으로 변경해야 함
-- 인덱스별로 압축 실행 횟수와 성공 횟수가 기록된다.
SET GLOBAL innodb_cmp_per_index_enabled=ON;

-- employees 테이블의 데이터를 그대로 압축 테스트 테이블로 저장
INSERT INTO employees_comp4k SELECT * FROM employees;

-- 인덱스별로 압축 횟수와 성공 횟수, 압축 실패율을 조회
SELECT
  table_name,
  index_name,
  compress_ops,
  compress_ops_ok,
  (compress_ops - compress_ops_ok) / compress_ops * 100 AS compression_failure_pct
FROM information_schema.INNODB_CMP_PER_INDEX;
```

#### KEY_BLOCK_SIZE를 4KB로 설정하고 테스트

<img width="480" height="113" alt="스크린샷 2025-10-19 오후 11 08 55" src="https://github.com/user-attachments/assets/33057b0d-18ba-4b58-bedf-4f92e6bb8246" />

* 압축된 테이블의 PRIMARY 키는 전체 18653번의 압축 시도 중 13478번 성공 -> 압축 실패율 27.67%
* 일반적으로 압축 실패율은 3-5% 미만으로 유지할 수 있게 KEY_BLOCK_SIZE를 선택하는 것이 좋다.


#### KEY_BLOCK_SIZE를 8KB로 설정하고 테스트

<img width="484" height="115" alt="스크린샷 2025-10-19 오후 11 11 09" src="https://github.com/user-attachments/assets/24135f42-834a-440f-a162-d2c98c4b2fe3" />

* 여전히 PRIMARY 키의  압축 실패율이 높게 나오는 것을 알 수 있다.

<img width="330" height="70" alt="스크린샷 2025-10-19 오후 11 12 16" src="https://github.com/user-attachments/assets/01fc24f8-44a3-462b-9791-0478b552c825" />

* 실제 데이터 디렉터리에 생성된 각 테이블의 크기를 살펴보면, 압축되지 않은 employees 테이블 크기는 30MB인 반면, 4KB 압축을 적용하면 20MB로 줄어든 것을 확인함
* 흥미로운 것은 4KB, 8KB의 압축 결과가 거의 차이가 나지 않는다는 것이다.
  * 이 경우에는 압축 실패율은 낮으면서 압축 효율은 상대적으로 높은 8KB를 선택하는 것이 좋다.  

### 압축된 페이지의 버퍼 풀 적재 및 사용

InnoDB 스토리지 엔진은 디스크에서 읽은 데이터 페이지 목록을 관리하는 `LRU 리스트`와 압축된 페이지들의 압축 해제 버전인 `Unzip_LRU` 리스트를 별도로 관리한다.
* `LRU 리스트` :  디스크에서 읽은 모든 InnoDB 페이지가 포함되므로, 압축되지 않은 페이지와 압축된 페이지 둘 다 가지게 된다.
* `Unzip_LRU 리스트` : 압축 테이블’(ROW_FORMAT=COMPRESSED)의 페이지 중, 압축이 풀린(unzipped) 버전만을 관리한다.
* 결국 버퍼풀의 공간을 이중으로 사용하는 것!

또 다른 문제점 ..
* 압축된 페이지에서 데이터를 읽거나 변경하기 위해서는 압축을 해제 해야하는데, 압축 및 압축 해제 작업은 CPU를 상대적으로 많이 소모한다.
  * 따라서, 버퍼풀 공간이 필요한 경우 LRU 리스트에서 원본 데이터 페이지는 유지하고, Unzip_LRU 리스트에서 압축 해제된 버전은 제거해서 버퍼풀의 공간을 확보한다.
  * 압축된 데이터 페이지가 자주 사용되는 경우에는 Unzip_LRU 리스트에 압축 해제된 페이지를 계속 유지하면서 압축 및 압축 해제 작업을 최소화한다.
  * 압축된 데이터 페이지가 사용되지 않아서 LRU 리스트에서 제거되는 경우네는 Unzip_LRU 리스트에서도 함께 제거된다.


### 테이블 압축 관련 설정

1. `innodb_cmp_per_index_enabled`
* 테이블 압축이 사용된 테이블의 모든 인덱스별로 압축 성공 및 압축 실행 횟수를 수집하도록 설정한다.
* innodb_cmp_per_index_enabled 시스템 옵션이 비활성화(OFF)되면 테이블 단위의 압축 성공 및 압축 실행 횟수만 수집된다.
* 테이블 단위로 수집된 정보는 information_schema.INNODB_CMP 테이블에 기록되며, 인덱스 단위로 수집된 정보는 information_schema.INNODB_CMP_PER_INDEX 테이블에 기록된다.

2. `innodb_compression_level`
* InnoDB의 테이블 압축은 zlib 압축 알고리즘만 지원하는데, 이때 innodb_compression_level 시스템 변수를 이용해 압축률을 설정할 수 있다.
* 0부터 9까지의 값 중에서 선택할 수 있는데, 값이 작을수록 압축 속도는 빨라지지만 저장 공간은 커질 수 있다. 반대로 값이 커질수록 속도는 느려질 수 있지만 압축률은 높아진다. (기본값=6)

3. `innodb_compression_failure_threshold_pct`와 `innodb_compression_pad_pct_max`
* 테이블 단위로 압축 실패율이 innodb_compression_failure_threshold_pct 시스템 설정값보다 커지면 압축을 실행하기 전 원본 데이터 페이지의 끝에 의도적으로 일정 크기의 빈 공간을 추가한다.
* 즉, 추가된 빈 공간은 압축 결과가 KEY_BLOCK_SIZE보다 작아지게 만드는 효과를 낸다. 여기서 추가하는 빈 공간을 패딩(Padding)이라고 하며, 이 패딩 공간은 압축 실패율이 높아질수록 계속 증가된 크기를 가지는데, 추가할 수 있는 패딩 공간의 최대 크기는 innodb_compression_pad_pct_max로 제한된다.

4. `innodb_log_compressed_pages`
* MySQL 서버가 비정상적으로 종료됐다가 다시 시작되는 경우 압축 알고리즘(zlib)의 버전 차이가 있더라도 복구 과정이 실패하지 않도록 InnoDB 스토리지 엔진은 압축된 데이터 페이지를 그대로 리두 로그에 기록한다.
* 이는 압축 알고리즘을 업그레이드할 때 도움이 되지만, 데이터 페이지를 통째로 리두 로그에 저장하는 것은 리두 로그의 증가량에 상당한 영향을 미칠 수도 있다.
* 압축을 적용한 후 리두 로그 용량이 매우 빠르게 증가하거나 버퍼 풀로부터 더티 페이지가 한꺼번에 많이 기록되는 패턴으로 바뀌었다면 innodb_log_compressed_pages 시스템 변수를 OFF로 설정한 후 모니터링해보는 것이 좋다.
* innodb_log_compressed_pages 시스템 변수의 기본값은 ON인데, 가능하면 기본값인 ON 상태를 유지하자.
