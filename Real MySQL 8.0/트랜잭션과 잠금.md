# 트랜잭션과 잠금

## 1. 트랜잭션

`트랜잭션`
* 논리적인 작업셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상을 발생하지 않게 만들어주는 기능을 말함

### 1-1. MySQL에서의 트랜잭션

```sql
CREATE TABLE table_myisam (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
INSERT INTO table_myiam (fdpk) VALUES (3);

CREATE TABLE table_innodb (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=INNODB;
INSERT INTO table_innodb (fdpk) VALUES (3);

# auto-commit 활성화
SET autocommit=ON;

INSERT INTO table_myiam (fdpk) VALUES (1), (2), (3);
INSERT INTO table_innodb (fdpk) VALUES (1), (2), (3);
```
* 테스트용 테이블에 각각 레코드를 1건씩 저장 후, auto-commit 모드에서 다음과 같은 쿼리를 실행해보자

```sql
INSERT INTO table_myisam (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

INSERT INTO table_innodb (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

SELECT * FROM table_myisam;

+------+
| fdpk |
+------+
|     1|
|     2|
|     3|
+------+

SELECT * FROM table_innodb;
+------+
| fdpk |
+------+
|     3|
+------+
```
* 두 문장 모두 프라이머리 키 중복 오류로 쿼리가 실패했으나, MyISAM 테이블의 경우에는 1과 2가 INSERT된 상태로 남아있는 것을 확인할 수 있음
* MyISAM 테이블에 INSERT 문장이 실행되면서 차례대로 1과 2를 저장하고 그 다음 3을 저장하려는 순간 중복 키오류가 발생했기 때문에 이미 insert된 1과 2를 그대로 두고 쿼리 실행을 종료해버림
* 반면 innoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원상태로 만든다는 트랜잭션의 원칙대로 Insert 문장을 실행하기 전 상태로 그대로 복구함 
* 트랜잭션이 없는 경우 부분 업데이트 현상이 발생하면 실패한 쿼리로 안해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 것임 (쿼리가 여러개라면..?🤯 트랜잭션은 좋은 기능이군!)

### 1-2. 주의사항

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋음 (데이터베이스 커넥션 수가 제한적이기 때문)

```python
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 발생 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
 ==> 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
 ==> 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
 <= 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
 ==> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
 <= 트랜잭션 종료(COMMIT)
 <= 데이터베이스 커넥션 종료(또는 커넥션 풀에 반납)
10. 처리 완료
```
* 실제로 많은 개발자가 데이터베이스의 커넥션을 생성하는 코드를 1번과 2번 사이에 구현하며 그와 동시에 트랜잭션을 시작함 ➡️ 그리고 9번과 10번 사이에서 트랜잭션을 커밋하고 커넥션을 종료함
* 하지만 실제 DB에 데이터를 저장하는 작업은 5번부터 시작된다는 것을 알 수 있고, 2번~4번의 절차가 아무리 빨리 처리된다고 하더라도 트랜잭션에 포함시킬 필요는 없음
* 또한 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 트랜잭션 내에서 제거하는 것이 좋음
  * 프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생한다면 웹 서버 뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생할 것
* 결론적으로 사용자가 입력한 정보를 저장하는 5번과 6번 작업은 반드시 하나의 트랜잭션으로 묶어야 하며, 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함할 필요가 없음


## 2. MySQL 엔진의 잠금 

### 2-1. 글로벌 락

`FLUSH TABLES WITH READ LOCK`
* MySQL에서 제공하는 락 중에 가장 범위가 크며, 인스턴스 전역 읽기 전용 상태에 가깝게 만듦 
* 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT을 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 떄까지 해당 문장이 대기 상태로 남음
* 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미침
* **🤔 언제 쓰나요?**
  * (과거) MyISAM 혼용 환경에서 논리 백업(mysqldump) 시 인스턴스 전체의 일관 스냅샷을 강하게 보장해야 할 때
  * 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치므로 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는게 좋음

### 2-2. 백업락 (MySQL 8.0+)

`LOCK INSTANCE FOR BACKUP` 
* 특정 세션에서 백업 락을 획득하면 모든 세션에서 **DDL(테이블 스키마/사용자의 인증 관련 정보 변경)을 차단하나 DML(일반적인 테이블의 데이터 변경)은 허용함**
* **복제(소스 ↔ 레플리카)와의 관계**
  * MySQL 서버의 구성은 소스 서버와 레플리카 서버로 구성되는데, 주로 백업은 레플리카 서버에서 실행됨
  * 백업 중 소스 서버에서 DDL이 발생해 레플리카로 넘어오면, 레플리카 인스턴스의 백업 락이 그 DDL의 적용을 막아 SQL 스레드가 해당 시점에서 대기하게 됨
  * 이로써 레플리카 데이터/메타 상태가 백업 시점에서 안정적으로 고정되어 일관성 있는 백업을 만들 수 있음
  * 따라서 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL명령이 실행되면 복제를 일시 중지하는 역할을 함 

### 2-3. 테이블 락

* 개별 테이블 단위로 설정되는 잠금
* 명시적으로 `LOCK TABLES table_name [READ | WRITE]` 명령으로 락을 획득할 수 있으며, `UNLOCK TABLES`명령으로 잠금을 해제할 수 있음
* 묵시적으로 테이블락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생 - 즉 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후 즉시 잠금을 해제하는 형태로 사용
  * 하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하므로, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블락이 설정되지 않음
  * 정확히는 InnoDB 테이블은 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침
 
### 2-4. 네임드 락

```
T1: row A 잠금 → row B 잠금 시도(대기)
T2: row B 잠금 → row A 잠금 시도(대기)
=> 서로 기다리다 데드락
```
* 네임드락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정
* 데드락이 발생하면 InnoDB는 이걸 감지해 둘 중 하나를 롤백시키지만, 사용자 입장에선 에러/재시도 비용이 생김
* 네임드락은 '이 이름을 가진 작업은 한 번에 하나만'이라는 약속 ➡️ 같은 자원(혹은 충돌 가능한 자원 집합)을 같은 이름의 락으로 표현
* 작업 시작 전에 GET_LOCK(name, timeout)으로 문 입구에 차례로 줄 세움. 들어간 작업이 끝나면 RELEASE_LOCK(name) ➡️ 이렇게 한 줄 세우면 동시 실행이 사라져 사이클이 원천 차단

### 2-5. 메타데이터 락

메타데이터 락(Metadata Lock, MDL)은 테이블·뷰 같은 객체의 정의(스키마)를 보호하기 위해 MySQL이 자동으로 거는 락
* ```RENAME TABLE table_a TO table_b```와 같이 테이블의 이름을 변경하는 경우 자동으로 락 획득

```sql
RENAME TABLE rank TO rank_backup, rank_new To rank;
```
* 위와 같이 하나의 RENAME TABLE 명령어에 두 개의 RENAME 작업을 한꺼번에 실행하면 실제 애플리케이션에서는 Table not found..같은 상황을 발생시키지 않고 적용하는 것이 가능함
* 이 문장을 두개로 나눠서 실행하면 아주 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생기며, 그 순간 실행되는 쿼리는 오류를 발생시킴













