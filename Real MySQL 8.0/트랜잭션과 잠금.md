# 트랜잭션과 잠금

## 1. 트랜잭션

`트랜잭션`
* 논리적인 작업셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상을 발생하지 않게 만들어주는 기능을 말함

### 1-1. MySQL에서의 트랜잭션

```sql
CREATE TABLE table_myisam (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
INSERT INTO table_myiam (fdpk) VALUES (3);

CREATE TABLE table_innodb (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=INNODB;
INSERT INTO table_innodb (fdpk) VALUES (3);

# auto-commit 활성화
SET autocommit=ON;

INSERT INTO table_myiam (fdpk) VALUES (1), (2), (3);
INSERT INTO table_innodb (fdpk) VALUES (1), (2), (3);
```
* 테스트용 테이블에 각각 레코드를 1건씩 저장 후, auto-commit 모드에서 다음과 같은 쿼리를 실행해보자

```sql
INSERT INTO table_myisam (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

INSERT INTO table_innodb (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

SELECT * FROM table_myisam;

+------+
| fdpk |
+------+
|     1|
|     2|
|     3|
+------+

SELECT * FROM table_innodb;
+------+
| fdpk |
+------+
|     3|
+------+
```
* 두 문장 모두 프라이머리 키 중복 오류로 쿼리가 실패했으나, MyISAM 테이블의 경우에는 1과 2가 INSERT된 상태로 남아있는 것을 확인할 수 있음
* MyISAM 테이블에 INSERT 문장이 실행되면서 차례대로 1과 2를 저장하고 그 다음 3을 저장하려는 순간 중복 키오류가 발생했기 때문에 이미 insert된 1과 2를 그대로 두고 쿼리 실행을 종료해버림
* 반면 innoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원상태로 만든다는 트랜잭션의 원칙대로 Insert 문장을 실행하기 전 상태로 그대로 복구함 
* 트랜잭션이 없는 경우 부분 업데이트 현상이 발생하면 실패한 쿼리로 안해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 것임 (쿼리가 여러개라면..?🤯 트랜잭션은 좋은 기능이군!)

### 1-2. 주의사항

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋음 (데이터베이스 커넥션 수가 제한적이기 때문)

```python
1. 처리 시작
2. 사용자의 로그인 여부 확인
3. 사용자의 글쓰기 내용의 오류 발생 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
 ==> 데이터베이스 커넥션 생성(또는 커넥션 풀에서 가져오기)
 ==> 트랜잭션 시작
5. 사용자의 입력 내용을 DBMS에 저장
6. 첨부 파일 정보를 DBMS에 저장
 <= 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
8. 게시물 등록에 대한 알림 메일 발송
 ==> 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS에 저장
 <= 트랜잭션 종료(COMMIT)
 <= 데이터베이스 커넥션 종료(또는 커넥션 풀에 반납)
10. 처리 완료
```
* 실제로 많은 개발자가 데이터베이스의 커넥션을 생성하는 코드를 1번과 2번 사이에 구현하며 그와 동시에 트랜잭션을 시작함 ➡️ 그리고 9번과 10번 사이에서 트랜잭션을 커밋하고 커넥션을 종료함
* 하지만 실제 DB에 데이터를 저장하는 작업은 5번부터 시작된다는 것을 알 수 있고, 2번~4번의 절차가 아무리 빨리 처리된다고 하더라도 트랜잭션에 포함시킬 필요는 없음
* 또한 메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 트랜잭션 내에서 제거하는 것이 좋음
  * 프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생한다면 웹 서버 뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생할 것
* 결론적으로 사용자가 입력한 정보를 저장하는 5번과 6번 작업은 반드시 하나의 트랜잭션으로 묶어야 하며, 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함할 필요가 없음


## 2. MySQL 엔진의 잠금 

### 2-1. 글로벌 락

`FLUSH TABLES WITH READ LOCK`
* MySQL에서 제공하는 락 중에 가장 범위가 크며, 인스턴스 전역 읽기 전용 상태에 가깝게 만듦 
* 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT을 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 떄까지 해당 문장이 대기 상태로 남음
* 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미침
* **🤔 언제 쓰나요?**
  * (과거) MyISAM 혼용 환경에서 논리 백업(mysqldump) 시 인스턴스 전체의 일관 스냅샷을 강하게 보장해야 할 때
  * 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치므로 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는게 좋음

### 2-2. 백업락 (MySQL 8.0+)

`LOCK INSTANCE FOR BACKUP` 
* 특정 세션에서 백업 락을 획득하면 모든 세션에서 **DDL(테이블 스키마/사용자의 인증 관련 정보 변경)을 차단하나 DML(일반적인 테이블의 데이터 변경)은 허용함**
* **복제(소스 ↔ 레플리카)와의 관계**
  * MySQL 서버의 구성은 소스 서버와 레플리카 서버로 구성되는데, 주로 백업은 레플리카 서버에서 실행됨
  * 백업 중 소스 서버에서 DDL이 발생해 레플리카로 넘어오면, 레플리카 인스턴스의 백업 락이 그 DDL의 적용을 막아 SQL 스레드가 해당 시점에서 대기하게 됨
  * 이로써 레플리카 데이터/메타 상태가 백업 시점에서 안정적으로 고정되어 일관성 있는 백업을 만들 수 있음
  * 따라서 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL명령이 실행되면 복제를 일시 중지하는 역할을 함 

### 2-3. 테이블 락

* 개별 테이블 단위로 설정되는 잠금
* 명시적으로 `LOCK TABLES table_name [READ | WRITE]` 명령으로 락을 획득할 수 있으며, `UNLOCK TABLES`명령으로 잠금을 해제할 수 있음
* 묵시적으로 테이블락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생 - 즉 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후 즉시 잠금을 해제하는 형태로 사용
  * 하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하므로, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블락이 설정되지 않음
  * 정확히는 InnoDB 테이블은 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침
 
### 2-4. 네임드 락

```
T1: row A 잠금 → row B 잠금 시도(대기)
T2: row B 잠금 → row A 잠금 시도(대기)
=> 서로 기다리다 데드락
```
* 네임드락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정
* 데드락이 발생하면 InnoDB는 이걸 감지해 둘 중 하나를 롤백시키지만, 사용자 입장에선 에러/재시도 비용이 생김
* 네임드락은 '이 이름을 가진 작업은 한 번에 하나만'이라는 약속 ➡️ 같은 자원(혹은 충돌 가능한 자원 집합)을 같은 이름의 락으로 표현
* 작업 시작 전에 GET_LOCK(name, timeout)으로 문 입구에 차례로 줄 세움. 들어간 작업이 끝나면 RELEASE_LOCK(name) ➡️ 이렇게 한 줄 세우면 동시 실행이 사라져 사이클이 원천 차단

### 2-5. 메타데이터 락

메타데이터 락(Metadata Lock, MDL)은 테이블·뷰 같은 객체의 정의(스키마)를 보호하기 위해 MySQL이 자동으로 거는 락
* ```RENAME TABLE table_a TO table_b```와 같이 테이블의 이름을 변경하는 경우 자동으로 락 획득

```sql
RENAME TABLE rank TO rank_backup, rank_new To rank;
```
* 위와 같이 하나의 RENAME TABLE 명령어에 두 개의 RENAME 작업을 한꺼번에 실행하면 실제 애플리케이션에서는 Table not found..같은 상황을 발생시키지 않고 적용하는 것이 가능함
* 이 문장을 두개로 나눠서 실행하면 아주 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생기며, 그 순간 실행되는 쿼리는 오류를 발생시킴

## 3. InnoDB 스토리지 엔진 잠금

### 3-1. InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없음

`레코드락`
* 특정 레코드 1개만 잠그는 락
* InnoDB 스토리지 엔진은 레코드 자체가 아니라, **인덱스 레코드**를 잠금
* 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정함
* `=`, `IN`같은 정확한 키 매칭으로 인덱스를 타고간 경우
  * ex) `SELECT .. FRO UPDATE WHERE id = 10`

`갭락`
* 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
* 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어해여 팬텀 레코드를 방지
* 범위 조건 (`>`, `<`, `BETWWEN`, 인덱스 범위 스캔)으로 **REPEATABLE READ**에서 SELECT ... FOR UPDATE/LOCK IN SHARE MODE, UPDATE, DELETE 등이 실행될 때
* 해당 범위 안으로의 INSERT를 막음
* 갭락 만으로는 기존 레코드 수정까지는 막지 않음(이건 레코드락 또는 넥스트 키 락이 담당)

`넥스트 키 락`
* 레코드락 + 오른쪽 갭을 합친 갭락
  * 해당 레코드와 그 바로 다음에 끼어드는 위치의 락도 함께 잠금 
* REPEATABLE READ에서 팬텀 방지의 기본 메커니즘
* 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 떄 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장

`자동 증가 락`
* `AUTO_INCREMENT`를 통해 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드가 중복되지 않고 순서대로 증가하는 일련번호 값을 가지게 되는데, InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 자동 증가락이라는 테이블 수준의 잠금을 제공함
* 트랜잭션과 상관없이 INSERT, REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨(명시적으로 락을 획득하고 해제하는 방법은 없으며, 아주 짧은 시간동안 걸렸다가 해제되는 락임)
* MySQL 5.1 이상으로부터는 innodb_autoinc_lock_mode라는 시스템 변수를 통해 자동 증가 락의 작동 방식을 변경할 수 있음
  * [관련 공식 문서](http://dev.mysql.com/doc/refman/8.4/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes)
  * `innodb_autoinc_lock_mode=0`: 5.0과 동일한 잠금 방식으로 자동 증가락을 사용
  * `innodb_autoinc_lock_mode=1`: INSERT되는 레코드의 건수를 정확히 예측할 수 있을 때는 뮤텍스 사용, SELECT처럼 예측이 불가한 경우 자동 증가 락 사용
  * `innodb_autoinc_lock_mode=1`: 자동 증가락을 절대 사용하지 않고 경량화된 뮤텍스를 사용 

### 3-2. 인덱스와 잠금

`emplyess` 테이블의 컬럼 `first_name`에 **인덱스**가 걸려있다고 가정

```sql
SELECT COUNT(*) FROM emplyees WHERE first_name='Georgi';
// 해당 쿼리의 결과가 253이라고 가정하자

SELECT COUNT(*) FROM emplyees WHERE first_name='Georgi' AND last_name='Klassen';
// 해당 쿼리의 결과가 1이라고 가정하자

UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```
* update 문이 실행되면 1건의 레코드가 업데이트되는데, 1건의 업데이트를 위해 253건의 레코드가 잠김
* InnoDB의 잠금은 레코드가 아닌 인덱스를 잠그기 때문!
* 따라서, update 문장을 위해 적절히 인덱스가 준비돼 있지 않으면 각 클라이언트 간의 동시성이 상당히 떨어질 것임.. 한 세션에서 update 작업을 하는 동중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하므로..

## 4. MySQL의 격리 수준

`트랜잭션의 격리 수준(isolation level)`
* 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

### 4-1. READ UNCOMMITTED

<img width="350" height="317" alt="스크린샷 2025-10-14 오후 5 17 24" src="https://github.com/user-attachments/assets/f00b4203-c19c-4942-8d2e-185659341fec" />

**트랜잭션에서 청리한 작업이 완료되지 않았는데, 다른 트랙잭션에서 볼 수 있는 현상**
* 사용자 A가 Insert 구문(emp_no=500000) 실행 -> 변경된 내용을 커밋하기도 전에 사용자 B가 emp_no=500000인 사원 검색
* 사용자 B는 사용자 A가 Insert한 사원의 정보를 커밋되지 않은 상태에서도 조회 가능
* 하지만 사용자 A가 Insert한 내용을 롤백하게되면, READ UNCOMMITTED 격리 수준에서는 여전히 해당 사원을 정상적인 사원이라고 생각하고 계속 처리할 수 있는 문제점 발생
* 정합성에 문제가 많은 격리 수준 (= dirty read)

### 4-2. READ COMMITTED

<img width="343" height="311" alt="스크린샷 2025-10-14 오후 5 23 21" src="https://github.com/user-attachments/assets/32c2770d-38a9-4e39-96e3-102fc1edb36f" />

**커밋이 완료된 데이터만 다른 트랜잭션에서 조회 가능**
* 사용자 A가 emp_no=500000인 사원에 대해 update문 실행 - 새로운 값(Toto)은 employees 테이블에 즉시 기록되고 이전 값(Lara)은 언두 영역에 백업
* 사용자 A가 커밋을 수행하기 전에 사용자 B가 emp_no=500000인 사원을 SELECT하면 언두 영역에서 Lara 조회, 커밋 후에는 Toto 값을 조회하게 됨

<img width="355" height="312" alt="스크린샷 2025-10-14 오후 5 27 31" src="https://github.com/user-attachments/assets/d49481f5-49b2-4c44-b54c-f0f712f93c41" />

**READ COMMITTED 격리 수준에서 발생하는 NON-REPEATABLE READ 문제**
* 사용자 B가 BEGIN 명령어로 트랜잭션을 시작하고, first_name이 Toto인 사용자를 select -> 일치하는 결과 없음 -> 사용자 A가 업데이트문으로 특정 사원을 Toto로 변경 후 커밋 -> 사용자 B가 똑같은 select 구문으로 재조회하면 이번에는 1건이 조회됨
* `NON-REPEATABLE READ` : select 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다

### 4-3. REPEATABLE READ (InnoDB 기본값)

InnoDB 스토리지 엔진은 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업한 실제 레코드 값을 변경함 - **MVVC 방식**
* REPEATABLE READ는 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보장함
* 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 번호가 포함되어있음
  
<img width="350" height="413" alt="스크린샷 2025-10-19 오후 5 03 08" src="https://github.com/user-attachments/assets/b53d1920-e4ee-4ac4-b88f-e5f69adcf67b" />

* 사용자 B의 10번 트랜잭션 안에서 실행되는 모든 SELECT 쿼리는 트랜잭션 번호가 10보다 작은 트랜잭션 번호에서 변경한 것만 보이는 문제
  * 자신의 트랜잭션 시작 시점보다 이전에 커밋된 버전만 볼 수 있음


<img width="410" height="382" alt="스크린샷 2025-10-19 오후 5 05 06" src="https://github.com/user-attachments/assets/8a203385-717e-4592-89e9-c6efa5f2aa83" />

`SELECT FOR UPDATE`는 현재 물리적 데이터에 락을 걸어야 하기 때문에, 일반 스냅샷 읽기(SELECT)와 달리 undo 레코드의 과거 버전이 아닌, 최신 버전(current version) 을 바라봄. 따라서 InnoDB는 아래와 같이 처리함.
* 스냅샷 읽기: 언두 체인을 따라가며 “트랜잭션 시작 시점의 커밋된 버전”을 반환
* 잠금 읽기(FOR UPDATE): 현재 레코드(가장 최신 버전)에 락을 걺

Phantom 문제 발생 구조 (언두 레코드 관점)

* 트랜잭션 T1: REPEATABLE READ로 시작
* 트랜잭션 T2: 새로운 행을 삽입하려 함

#### 1️⃣ T1이 먼저 실행
```
T1: BEGIN;
T1: SELECT * FROM employees WHERE emp_no > 50000 FOR UPDATE;
```
이 시점에 InnoDB는 emp_no > 50000 조건에 맞는 현재 존재하는 레코드들에만 락을 검. undo log를 따라가며, “커밋된 최신 버전”을 기준으로 판단.  
존재하지 않는 행(예: 새로 삽입될 행)은 언두 체인에 없음 → 락 불가능.

#### 2️⃣ T2가 새로운 행 삽입
```
T2: INSERT INTO employees VALUES (50001, 'Georgi');
T2: COMMIT;
```
이 행은 undo 체인에 없던 새로운 버전(v1) 이 만들어짐. T1의 스냅샷에는 이 행이 존재하지 않으므로, T1은 이 행을 전혀 인식하지 못함.

#### 3️⃣ T1이 다시 같은 쿼리를 실행
```
T1: SELECT * FROM employees WHERE emp_no > 50000 FOR UPDATE;
```
REPEATABLE READ에서는 트랜잭션 시작 시점의 스냅샷 을 유지하므로 여전히 삽입된 row는 보이지 않음.  
즉, 언두 체인 상의 과거 버전만 접근 가능 → 새로운 버전(v1 of new row)은 읽지 않음.  
👉 결과적으로 T1은 “같은 SELECT인데 새로운 행이 안 보인다." Phantom Read

### 4-4. SERIALIZABLE

* 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것
* Phanton Read 문제 발생하지 않음
  * 하지만 InnoDB 스토리지 엔진에서 갭 락과 넥스트 키 락 덕분에 Phanton Read 문제가 발생하지 않기 때문에 굳이 해당 격리 수준을 사용할 필요가 없어 보임

### 4-5. 정리

<img width="575" height="170" alt="스크린샷 2025-10-14 오후 5 14 55" src="https://github.com/user-attachments/assets/b2e82436-e0ef-4ea3-96bd-d2d6a1e504a6" />








