# MySQL 아키텍처

## 1. 전체 구조
<img width="359" height="360" alt="스크린샷 2025-10-27 오후 2 46 48" src="https://github.com/user-attachments/assets/85a9b1c8-03b8-4ec4-bd43-1adf771962cd" />

### 1-1. MySQL 서버

1. 커넥션 핸들러
* MySQL 서버가 스토리지 엔진(InnoDB, MyISAM 등)과 대화할 때 쓰는 C++ 인터페이스 
* 내부적으로 모든 SELECT/INSERT/UPDATE/DELETE가 이 API 호출로 변환돼 실행됨
* 따라서 `SHOW STATUS LIKE 'Handler_%'`로 보면 핸들러 레벨에서 몇 번 읽고 썼는지를 확인 가능
2. SQL 파서
* 쿼리 문자열을 토큰화 → 구문 트리(AST)로 변환하며 문법 오류를 발견
3. 전처리기
* 파서가 만든 AST를 의미 해석 후 테이블/칼럼/함수/권한을 실제 객체와 매핑
4. 옵티마이저
* 전처리된 쿼리를 여러 실행계획 후보로 바꿔 가장 비용이 낮은 계획을 고름

### 1-2. 스토리지 엔진
* 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어옴

## 2. 스레딩 구조

<img width="481" height="292" alt="스크린샷 2025-10-27 오후 3 14 31" src="https://github.com/user-attachments/assets/75354427-43ce-4b2a-b76f-028ee3042bbb" />

#### 1. 포그라운드 스레드

* 클라이언트 요청을 직접 처리하는 사용자 스레드
* 앱이 연결을 열고 쿼리를 보내면, 그 연결을 담당하는 스레드가 생성(또는 재사용)되어 파싱→최적화→실행→결과 전송까지 전 과정을 수행
* 클라이언트 사용자가 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아가며, 일정 개수 이상의 대기 중인 스레드가 캐시에 존재하면 종료시킴(thread_cache_size 시스템 변수로 스레드 캐시에 유지할 수 있는 최대 스레드 개수를 설정)
  
#### 2. 백그라운드 스레드

* 인서트 버퍼를 병합하는 스레드
* 로그를 디스크로 기록하는 스레드
* InnoDB 버퍼풀의 데이터를 디스크에 기록하는 스레드
* 데이터를 버퍼로 읽어오는 스레드
* 잠금이나 데드락을 모니터링하는 스레드

## 3. 메모리 할당 및 사용 구조

<img width="400" height="203" alt="스크린샷 2025-10-02 오후 12 24 54" src="https://github.com/user-attachments/assets/daacf983-a06c-47f0-8f3d-4bec30a82c40" />

#### 3-1. 글로벌 메모리 영역

* MySQL 서버가 시작되면서 운영체제로부터 할당됨
* MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당 받음
  * 운영체제의 종류에 따라 요청된 메모리 공간을 100% 할당해줄 수도 있고, 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있음 
* 클라이언트 스레드의 수와 무관하게 하나의 메모리공간만 할당되고, 모든 스레드에 의해 공유됨

#### 3-2. 로컬 메모리 영역 (=세션 메모리 영역)

* MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
* 각 클라이언트 스레드별로 독립적으로 할당되며, 절대 공유되어 사용되지 않음
 * 소트버퍼, 조인버퍼 ➡️ 쿼리를 실행하는 순간에만 공간 할당
 * 커넥션 버퍼, 결과버퍼 ➡️ 커넥션이 열려있는 동안 계속 할당된 상태로 유지 

## 4. 쿼리 실행 구조

<img width="429" height="283" alt="스크린샷 2025-10-02 오후 4 06 21" src="https://github.com/user-attachments/assets/363da393-683b-4b94-b67c-95987dc8e067" />

#### 1) 쿼리 파서

* 사용자 요청으로 들어온 문장을 MySQL이 인식할 수 있는 최소단위의 어휘/기호로 분리해 트리 형태의 구조를 만들어내는 작업
* 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고, 사용자에게 오류 메세지를 전달하게 됨

#### 2) 전처리기

* 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
* 각 토큰을 테이블 이름이나 컬럼 이름 또는 내장함수와 같은 개체를 매핑해 해당 객체의 존재여부와 객체의 접근 권한등을 확인함
  * 이 단계에서 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰이 걸러짐

#### 3) 옵티마이저

* 사용자의 요청으로 들어온 쿼리 문장을 가장 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할

#### 4) 실행엔진

* 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

#### 5) 핸들러 (스토리지 엔진)

* 실행엔진의 요청에 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어 오는 역할을 담당
* MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우에는 핸들러가 InnoDB 스토리지 엔진이 됨

## 5. 쿼리 캐시

* 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환함
* 쿼리 캐시는 테이블의 데이터가 변경되면 캐시에 저장된 결과중에서 변경된 테이블과 관련된 것들은 모두 삭제해야했기 때문에 동시 처리 성능 저하를 유발했음
  ➡️ 따라서 8.0으로 올라오면서 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거되었음

## 6. 스레드 풀

* 동시 실행 스레드를 CPU가 감당 가능한 수준으로 제한·스케줄링해 컨텍스트 스위치와 스케줄러 오버헤드를 줄이고, 짧은 작업을 더 빨리 처리하도록 도움 
* 제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도한다면, CPU 친화도(Processor affinity)가 높아지고, 운영체제 부담·스위치 비용이 감소
* 스레드 그룹 수
  * 기본은 CPU 코어 수와 동일한 그룹 수 생성
  * 시스템 변수 `thread_pool_size`로 조정 가능 (일반적으로 코어 수에 맞추는 것이 좋음)
  * 이미 스레드 풀이 처리 중인 작업이 있는 경우 `thread_pool_oversubscribe(기본 3)`를 초과 허용해 일시적으로 그룹 내 추가 작업을 받을 수 있음
* 스레드 그룹 안의 스레드가 바쁘면 새 워커 추가 또는 기존 작업 완료까지 대기 중 하나를 선택
  * 스레드 풀 타이머가 주기적으로 상태를 점검하여, pool_stall_limit(밀리초) 동안 작업이 끝나지 않으면 새 스레드 생성해 그룹에 붙임(지연에 민감한 서비스면 해당 값을 낮게 설정하되 0에 너무 가깝게 설정 금지)
* 우선순위 큐(선순위/후순위):
  * Percona 스레드 풀은 선순위 큐를 지원해 특정 트랜잭션을 먼저 처리 가능
  * 먼저 시작된 트랜잭션 내의 짧은 SQL을 빨리 해소해 락·경합을 줄이고 전체 성능을 안정화

# InnoDB 스토리지 엔진 아키텍쳐

<img width="337" height="304" alt="스크린샷 2025-10-27 오후 4 03 25" src="https://github.com/user-attachments/assets/b93726da-30a1-45f9-a99f-f6c4517e1f01" />

## 1. 프라이머리 키에 의한 클러스터링
## 2. 외래 키 지원
## 3. MVCC
## 4. 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
## 5. 자동 데드락 감지
## 6. 자동화된 장애 복구
## 7. InnoDB 버퍼 풀

